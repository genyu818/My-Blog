# MYSQL的基础架构

### 1.	MYSQL架构

Mysql可分为Server层和存储引擎两部分。



### 1.1	Server层

Server层包括连接器、查询缓存、分析器、优化器、执行器，涵盖MYSQL的大多数服务核心功能，以及所有的内置函数，所有跨存储引擎的功能都在这一层实现，比如存储过程，触发器，视图等。

#### 1.	连接器

用来连接Mysql客户端和服务端。

Notes：数据库连接也有长连接，但是长时间使用长连接会发现内存飙升，因为连接管理是在内存中的，如果不断开连接，就会在内存中一直占用。

#### 2.	查询缓存

MySQL 8.0 版本直接将查询缓存的整块功能删掉了

#### 3.	分析器

根据SQL语句做词法分析，判断SQL是否符合Mysql规范。

#### 4.	优化器

优化器是有多个索引时，Mysql决定使用哪个索引，如果一个语句有多个join，决定各个表关联顺序。

#### 5.	执行器

开始执行语句，首先会判断是否有表权限，如果有权限，会去执行sql，根据表的引擎定义去找引擎接口。



### 1.2	存储引擎

存储引擎负责的是数据的存储以及提取，MYSQL支持InnoDB，MyisAM等多个引擎。**不同的存储引擎共用一个 Server 层**



### 1.3	日志系统



#### 1.	redo log

redo log:	当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。

redo log是追加循环写，到达一定量时会删除旧的数据。

redo log是为了crash safe而存在。



#### 2.	binlog

binlog是server日志文件，将数据库所有的操作追加写到log中，作用是为了归档。



#### 3.	redo log和bin log的区别

1. redo log是InnoDB引擎专有，binlog是server层中的（所有引擎都会有）
2. redo log是物理日志(记录了某个数据页上做了什么修改)，binlog是逻辑日志，记录的是sql逻辑
3. redo log是循环写的，固定空间会用完，binlog是追加写，空间上限再磁盘



### 1.4	两阶段提交

redo log写入分为两个部分，prepare和commit，这就是两阶段提交。

回顾一下binlog是为了归档，redolog是为了crash-save

假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？

1. 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。
2. 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。