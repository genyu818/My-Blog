# 索引



### 1.索引的常见模型

#### 哈希表

数组+链表(拉链法解决冲突)，**缺点是不好范围查询**，适合等式查询

#### 有序数组

查询效率很高，但是更改效率非常差，适合静态表。

#### 搜索树

Mysql使用的是N叉树。



### 2.	InnoDB中的索引

InnoDB中每个索引都是一颗B+树，一张表是数棵B+树（主键索引树和非主键索引树）。

主键索引树结点的key值就是某一行的主键，value是该行的其他数据。新建索引就是新增一个B+树，查询不走索引就是遍历主B+树。



假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。这个表的建表语句是

```sql
create table T(id int primary key, k int not null, name varchar(16),index (k))engine=InnoDB;
```

表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。



<img src="D:\Blog\My-Blog\Article\Mysql\mysql01.png" alt="img" style="zoom:50%;" />



从图上可得知，主键索引树上叶子节点存储的整行数据，非主键索引树上存储的是主键索引。

基于主键索引和普通索引的查询有什么区别？

1. 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
2. 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。



也就是说基于非主键索引需要查找两棵树，所以要尽量使用主键索引。



#### 索引的维护

增加索引可能会导致页分裂，删除索引可能会导致页合并。最好使用自增主键作为索引。

**同时，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**



#### 覆盖索引

之前说过从非主键索引树找到主键索引再回到主键索引树查找的过程叫做回表。

如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为**覆盖索引**。



#### 最左前缀原则

InooDB可以使用联合的索引中的前N个字段或者字符串索引中的前N的个字符来匹配索引。



基于上面对最左前缀索引的说明，有一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。

这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。



#### **索引下推**

注意

**mysql 会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配。**

例如有一张市民表的联合索引（name, age）。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。

那么，SQL 语句是这么写的：

```sql
 select * from tuser where name like '张%' and age=10 and ismale=1;
```

根据前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”



然后呢？

当然是判断其他条件是否满足。

在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。

而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， **可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。**

例如再执行之前语句时，因为age也在联合索引中，所以遍历过程中会过滤掉age不为10的记录。



## 3.	普通索引和唯一索引

#### select

#### update

##### change buffer