# 类加载子系统

一个类从被加载到虚拟内存开始，到卸除内存为止，它的整个生命周期会经历加载，验证，准备，解析，初始化，使用和卸载七个阶段。其中验证，准备，解析又被称为连接阶段。



## 1	类加载的时机

JVM严格规定了有且只有6中情况下会对类进行``初始化``

* 遇到new，getstatic，putstatic，invokestatic这四条字节码命令时，常见场景如下
  * new一个对象时
  * 读取或者只静态字段时
  * 调用一个类的静态方法时
* 使用反射时
* 有继承时，需要初始化父类
* 虚拟机启动时，会初始化主类
* ...





Notes:	对于静态字段，只有直接定义这个字段类，才会被初始化。因此通过子类调用父类总定义的静态字段，只会初始化父类，不会初始化子类。





类加载器子系统负责从文件系统或者网络中加载Class文件，Class文件在文件开头有特定的文件标识。

ClassLoader只负责class文件的加载，至于能否运行，则有Execution Engine决定。

类加载后存放在方法区内。



## 2.	类加载的过程

### 2.1	加载阶段

加载阶段，JAVA虚拟机需要完成一下三件事

1. 通过一个类的全限名获取它的二进制字节流
   * 从ZIP包获取，例如JAR，WAR
   * 从网络中获取，Web Applet
   * 运行时计算，常见的时动态代理
   * ...
2. 将字节流中的静态文件转到方法区中
3. 在内存中生成一个代表该类的Class文件作为方法区中这个类的各个数据的入口



### 2.2	连接阶段

#### 2.2.1	验证

验证时连接的第一阶段，这一阶段要确保Class文件的字节流中包含的信息符合规范要求，保证这些信息被当作代码运行后不会危害虚拟机。

1. 文件格式验证：针对字节流的验证，只有经过该阶段验证，字节流才会分配到方法区进行存储。
   * 是否以 0xCAFEBABY开头（Class字节流的影响规定）
   * ...
2. 元数据验证：对字节码描述的语义分析
   * 这个类是否有父类
   * 这个类是否继承了不被允许继承的类(final)
   * 如果不是抽象类，是否重写了所有继承的方法
   * ...
3. 字节码验证：对类的方法体进行校验，保证类的方法在运行时不会做出危害虚拟机安全的行为
   * 不会出现定义一个List<String>确使用List<Integer>来操作
   * 保证任何的跳转指令都不会跳转到方法体外的字节码中
   * 保证方法体中的类型转换正确(比如把对象赋值给和它毫无继承关系，完全不相干的一个类中)
4. 符号引用验证：对类自身以外(例如常量池的各种引用)的各类信息进行校验



#### 2.2.2	准备阶段

准备阶段就是为静态变量设置分配内存和初始化(不包括实例变量)。

这里说的初始话，是将值时赋为零值，即下面一条赋值在准备阶段会将 value置为0而不是100。

```java
public static int value  = 100;
```

但是使用final修饰的静态值就会赋为定义值，即下面一条赋值在准备阶段会将 value置为100而不是0。

```java
public static final int value  = 100;
```



#### 2.2.3	解析阶段

解析阶段是将常量池中的符号引用替换为直接引用的过程。



### 2.3	初始化阶段

初始化阶段会根据程序员通过编码指定的主观计划去初始化类变量和其他资源。初始化阶段实际是执行构造器<client>()方法的过程，<client>()是Javac编译器的自动生成物。

有以下几个重点

1. <client>()是编译器自动收集类变量的赋值动作和静态代码块中的语句合并产生的，编译器收集的顺序是根据代码的顺序而来。
2. JVM会保证子类的<client>()执行前，父类的<client>()已经执行完成了。即父类中定义的静态语句块要优先于子类的变量赋值操作。
3. <client>()没有静态变量不会生成。
4. <client>()在多线程的情况下会加锁。



## 3.	类加载机制

### 3.1	类加载器

1. 启动类加载器：由C++实现，是虚拟机的一部分。
   * Bootstrap ClassLoader
     * 存在放<JAVA_HOME>/lib下，按照文件名识别例如rt.jar, tool.jar, java*.java
     * 例如String等核心类
     * 使用getClassLoader方法会返回null
2. 自定义类加载器：由Java实现继承java.lang.ClassLoader，独立于虚拟机之外
   * Extension Class Loader
     * 存放还<JAVA_HOME>\lib\ext下
     * JDK允许，用户将通用性类库放置在ext下来扩展JAVA SE功能
3. 应用程序类加载器
   * Application Class loader（系统类加载器）
     * 它负责加载用户路径(ClassPath)下的所有类。
     * 如果应用程序中没有自定义的类加载器，一般都是使用系统类加载器



### 3.2	双亲委派机制

双亲委派的工作流程是，如果一个类加载器收到加载请求时，它不会先去加载而是委托给它的夫类加载器去加载。因此所有的类加载都会交给Bootstrap ClassLoader来加载，如果加载失败会一层层往下尝试，如果全部失败，才会交给本身的类加载器来加载。



双亲委派的好处

1. 保证Java类型体系中的最基础行为(沙箱安全机制)
   * 如果我们自定义一个类叫做java.lang.Object，没有双亲委派的情况下会直接加载我们写的类，那么Java体系就会收到干扰。