# 运行时数据区

![image-20201024102633402](https://github.com/genyu818/My-Blog/blob/main/image/jvm02_1)



## 1.	程序计数器

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码行号指示器。字节码解释器工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令（执行引擎会读取程序计数器来拿到具体操作）

计算机的每一个处理器都会执行一个线程的指令。因此为了线程切换后能恢复到正确位置，每个线程都会有程序计数器来记录现成的字节码指令地址。

程序计数器是JVM 内存中唯一一个没有GC和OOM的内存空间。

![image-20210426193810777](D:\Blog\My-Blog\pic\jvm02_2)



## 2.	Java虚拟机栈

与程序计数器一样，Java虚拟机栈也是线程私有并且随着线程销毁而销毁的。虚拟机栈描述的是Java方法执行的线程模型，每一个方法被执行的时候，Java虚拟机栈都会同步创造一个栈帧用于存储局部变量表、操作数栈、动态链接等信息。每一个方法被调用直至执行完毕，就对应着一个栈桢在虚拟机栈中从入栈到出栈的结果。

![image-20210427124003834](D:\Blog\My-Blog\pic\jvm02_3)

Java虚拟机栈中做什么？

1. 每个线程都有自己的栈，栈中的数据都是以**栈帧**（Stack Frame）的格式存在
2. 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。
3. 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。
4. 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
5. 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。
6. 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。(用递归来举例，同一个递归函数，栈越大Stackoverflow Error会越晚出现)

### 2.1	栈帧结构分析

**栈帧**是虚拟机栈中的单位，栈帧中由一下5部分构成

![image-20211124211650027](D:\Blog\My-Blog\pic\jvm02_4)



#### 2.1.1	局部变量表

栈帧中会定义一个数字数组来存储方法参数、定义方法内部变量、对象引用地址和return address，即是局部变量表。 

在局部变量表，**最基本的存储单元是Slot（变量槽）**，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。

![image-20211124211719408](D:\Blog\My-Blog\pic\jvm02_5)



**32位以内的类型只占用一个slot**（包括returnAddress类型），**64位的类型占用两个slot**（1ong和double）。

- byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true
- long和double则占据两个slot

同时JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。



Notes：局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收(可达性分析)。



#### 2.1.2	操作数栈

每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 **操作数栈**，也可以称之为**表达式栈**（Expression Stack）。操作数栈是在方法执行过程中，**根据字节码指令，往栈中写入数据或提取数据**，即入栈（push）和 出栈（pop）。

操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。

操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。**只不过操作数栈是用数组这个结构来实现的而已**。

#### 2.1.3	动态链接

每一个栈帧内部都包含**一个指向运行时常量池中该栈帧所属方法的引用**。包含这个引用的目的就是**为了支持当前方法的代码能够实现动态链接**（Dynamic Linking），比如：invokedynamic指令。

在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**。

#### 2.1.4	方法返回地址

该区域存放着调用该方法的PC寄存器的值。一个方法的结束，有两种方式：

- 正常执行完成
- 出现未处理的异常，非正常退出

无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，**调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址**。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。

### 2.2	常见问题

1. SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM
2. 虚拟机栈中不会涉及GC。
3. Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。
   - 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个**StackoverflowError** 异常。
   - 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 **OutofMemoryError** 异常。
