# Spring事务详解

事务是数据库操作的最基本的单元，逻辑上一组操作，要么全成功，只有有一个失败就全部失败。

事务有四大特性(ACID)

1. 原子性
2. 一致性
3. 隔离性
4. 持久性



## 1.	如何在Spring中使用事务

提起事务，大家最经常举例就是银行转账系统，比如A给B转了100元需要有一下操作

1. A的银行卡少100元
2. B的银行卡多100元

此时如果A转账的过程中系统出现宕机，导致B没有收到100元，正常逻辑下A少了100元，B却没有多100元，A的100元不翼而飞了，那是肯定不行的。

所以在有事务的前提下，如果A转账后发生宕机，B为收到钱，那么根据事务的原子性A转出的100元应该回到A的账户。下面我们就使用SpringBoot来实现转账业务逻。





Spring中有两种方式实现事务: 编程式管理，声明式事务管理

声明式事务管理

1. 基于XML
2. 基于注解
   1. 引入注解依赖
   2. 添加注解@Transactional





@Transactional属性

![image-20211023220804640](D:\Blog\My-Blog\image-20211023220804640.png)

propagation：事务的传播行为

isolation：隔离界别

timeout：超时（事务需要在一定时间提交，如果不提交就会回滚）

readonly：是否只读

rollbackFor：回滚（设置出现哪些异常进行事务回滚）

noRollback：回滚（设置出现哪些异常不进行回滚）





### 2.	事务的传播行为

传播行为是多事务方法调用中，事务该怎么进行处理，就是事务的传播行为。



Spring的事务传播行为有以下7种

| 事务传播行为类型               | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| PROPAGATION_REQUIRED(主要)     | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 |
| PROPAGATION_REQUIRES_NEW(主要) | 新建事务，如果当前存在事务，把当前事务挂起。                 |
| PROPAGATION_MANDATORY          | 使用当前的事务，如果当前没有事务，就抛出异常。               |
| PROPAGATION_SUPPORTS           | 支持当前事务，如果当前没有事务，就以非事务方式执行。         |
| PROPAGATION_NOT_SUPPORTED      | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。   |
| PROPAGATION_NEVER              | 以非事务方式执行，如果当前存在事务，则抛出异常。             |
| PROPAGATION_NESTED             | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |





### 3.	事务的隔离级别

多事务操作(并发操作)之间不会产生影响，不考虑隔离性会产生很多问题，主要是

1. 脏读 ： 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据

   <img src="D:\Blog\My-Blog\pic\20210302203542344s_0.png.jpg" alt="20210302203542344s_0.png" style="zoom: 50%;" />

   

2. 不可重复读 ： 不可重复度指A事务对一条记录进行修改，尚未提交，B事务第一次查询该记录，看到的是修改之后的结果，此时A发生回滚，B事务又一次查询该记录，看到的是回滚后的结果。同一个事务内，B两次查询结果不一致。

   <img src="D:\Blog\My-Blog\pic\20210302203542344s_1.jpg" alt="20210302203542344s_1" style="zoom:50%;" />

3. 虚读：幻读就是指A事务对所有记录进行修改，尚未提交，此时B事务创建了一条新记录，A、B都提交。A查看所有数据，发现有一条数据没有被修改，因为这是B事务新增的，就想看到了幻象一样。

   <img src="D:\Blog\My-Blog\pic\20210302203542344s_2.png.jpg" alt="20210302203542344s_2.png" style="zoom: 50%;" />



事务的隔离级别

1. DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.
2. 未提交读（read uncommited） :允许事务看到其它事务修改了但未提交的数据，这意味着有可能是脏读、不可重复读或者幻读。
3. 已提交读 （read commited）:一个事务在未提交之前，所做的修改不会被其它事务所看见。这能避免脏读，但避免不了不可重复读和幻读。
4. 可重复读 （repeatable read） :避免了脏读和不可重复读，但幻读依然是有可能发生的。
5. 串行化的 （serializable） :避免了脏读、不可重复读以及幻读。



关于事务的四种隔离级别，其主要区别点也就在于是否能够解决这三个问题。这四种事务的隔离级别主要区别如下：

- **Read uncommitted**：这是隔离性最低的一种隔离级别，在这种隔离级别下，当前事务能够读取到其他事务已经更改但还未提交的记录，也就是脏读；
- **Read committed**：顾名思义，这种隔离级别只能读取到其他事务已经提交的数据，也就解决了脏读的问题，但是其无法解决不可重复读和幻读的问题；
- **Repeatable read**：从事务的定义上，这种隔离级别能够解决脏读和不可重复读的问题，但是其无法解决幻读的问题；
- **Serializable**：也称为序列化读，这是隔离性最高的一种隔离级别，所有的事务执行（包括查询）都会为所处理的数据加锁，操作同一数据的事务将会串行的等待。

​     从事务隔离级别的定义上可以看出，Serializable级别隔离性最高，但是其效率也最低，因为其要求所有操作相同记录的事务都串行的执行。这里需要说明的是，对于MySql而言，其默认事务级别是Repeatable read，虽然在定义上讲，这种隔离级别无法解决幻读的问题，但是MySql使用了一种`Next key-lock`的算法来实现Repeatable read，这种算法是能够解决幻读问题的。关于`Next key-lock`算法，在进行查询时，其不仅会将当前的操作记录锁住，也会将查询所涉及到的范围锁住。也就是说，其他事务如果想要在当前事务查询的范围内进行数据操作，那么其是会被阻塞的，因而MySql在Repeatable read隔离级别下就已经具备了Serializable隔离级别的事务隔离性



### 4.	常见的事务失效原因



#### 4.1	数据库引擎不支持事务

这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB。

#### 4.2	注解所在类没有被加载成Bean

如下面例子所示：

```java
// @Service
public class OrderServiceImpl implements OrderService {

    @Transactional
    public void updateOrder(Order order) {
        // update order
    }

}
```



#### 4.3	方法不是 public 的

`@Transactional` 只能用于 public 的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 `AspectJ` 代理模式。



#### 4.4	方法被final修饰

spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。

但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。



#### 4.5	多线程调用

```java
@Transactional
public void add(UserModel userModel) throws Exception {
    userMapper.insertUser(userModel);
    new Thread(() -> {
        roleService.doOtherThing();
    }).start();
	}
}
```

从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。

这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。



#### 4.6	错误的传播特性

如果我们在手动设置propagation参数的时候，把传播特性设置错了，比如：

```java
@Service
public class UserService {

    @Transactional(propagation = Propagation.NEVER)
    public void add(UserModel userModel) {
        saveData(userModel);
        updateData(userModel);
    }
}
```

我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。

目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。

### 

#### 4.7	异常被吃了

当业务方法抛出异常，spring感知到异常的时候，才会做事务回滚的操作，若方法内部将异常给吞了，那么事务无法感知到异常了，事务就不会回滚了。

如下代码，事务操作2发生了异常，但是被捕获了，此时事务并不会被回滚

```java
@Transactional
public void m1(){
    事务操作1
    try{
        事务操作2，内部抛出了异常
    }catch(Exception e){
        
    }
}
```



#### 4.8	手动抛了异常

```java
@Transactional
public void add(UserModel userModel) throws Exception {
    try {
        saveData(userModel);
        updateData(userModel);
    } catch (Exception e) {
        log.error(e.getMessage(), e);
        throw new Exception(e);
    }
}
```

上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。

因为spring事务，默认情况下只会回滚`RuntimeException`（运行时异常）和`Error`（错误），对于普通的Exception（非运行时异常），它不会回滚。

### 

#### 4.9	自定义了回滚异常

在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置`rollbackFor`参数，来完成这个功能。

但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：

```
@Slf4j
@Service
public class UserService {
    
    @Transactional(rollbackFor = BusinessException.class)
    public void add(UserModel userModel) throws Exception {
       saveData(userModel);
       updateData(userModel);
    }
}
```

如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了SqlException、DuplicateKeyException等异常。而BusinessException是我们自定义的异常，报错的异常不属于BusinessException，所以事务也不会回滚。

即使rollbackFor有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。

这是为什么呢？

因为如果使用默认值，一旦程序抛出了Exception，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：Exception或Throwable。

### 