# 传输层

网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

#### **传输层和网络层的区别？**

**传输层：向两个主机中进程之间的通信提供服务**

网络层：一个分组内的主机之间的通信服务



## 1.	运输层协议一：TCP

传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）

## 2.	运输层协议二：UDP

用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。



## 3.	TCP 的三次握手

![image-20220315205244133](D:\Blog\My-Blog\image\http01_3)

1. 服务端处于Listen状态
2. 客户端发送请求连接，SYN(同步序号) = 1，ACK =0，选择一个初始序号x
3. 服务端手动请求连接，如果同意连接，SYN = 1，ACK =1 ，ack(确认号)为x + 1，选择一个序号为y
4. 客户端确认连接，ACK 为1 ，ack为y + 1，序号为x + 1
5. 服务端收到客户端的确认，建立连接



**为什么需要三次握手建立连接？**

防止失效的连接到达服务器，让服务错误打开连接

客户端发送的请求如果在网络中滞留，那么就会隔很长时间才会收到服务端的连接确认。客户端如果发生超时重传，就会重新请求连接，但是滞留的那个请求依旧会到达服务端，如果没有三次握手的话，服务就会打开两个连接。





## 4.	TCP四次挥手

![image-20220315210407521](D:\Blog\My-Blog\image\http01_4)

1. A发出断开连接请求 FIN = 1， 选择序号seq = u
2. B同意断开连接，但是要将此时的数据传送完，ACK为1，选择序号为v，确认号u + 1
3. B将数据传输完后，通知A数据已传输完毕，FIN =1 ，ACK =1，选择序号为w，确认号为u+1
4. A收到确认后，等待2MSL(报文最大传输时间)，释放连接
5. B收到A的请求后释放连接



**为什么需要四次挥手断开连接？**

客户端发送断开连接请求时，服务端进入了CLOSE_WAIT状态，为的是让服务端传输未传输完的数据，等待数据传输完成之后再发送FIN释放报文。



**为什么客户端收到释放报文之后要等待2MSL时间？**

为了确保最后一个报文可成功到达，如果服务端没有收到客户端的确认报文，会再次发送释放连接请求报文，A等待一段时间就是为了处理这种情况。



## 5.	滑动窗口

窗口是缓存的一部分用来存放字节流，接收方通过TCP报文的窗口，告诉发送接受方窗口的大小，发送方根据此信息确认发送窗口的大小。

发送窗口允许被发送，接收窗口允许接受。如果发送窗口的左部的字节已经被接受，窗口就相应的滑动，直到未接受的字节。接收方也类似。



## 6.	TCP流量控制

接收方通过确认TCP报文中的窗口，限制发送方窗口的大小，如果窗口值设为0，则无法传输数据。

