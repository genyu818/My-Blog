HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。



### TCP/IP四层协议(TCP/IP协议负责传输的底层工作)

1. 链接层(使用MAC地址标记唯一的网络设备)
2. 网际层(IP层，负责IP寻址)
3. 传输层(TCP层，保证数据在IP地址标记的两点可靠的传输)
4. 应用层(HTTP,SMB...)



### OSI七层模型

1. 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；
2. 第二层：数据链路层，它基本相当于 TCP/IP 的链接层；
3. 第三层：网络层，相当于 TCP/IP 里的网际层；
4. 第四层：传输层，相当于 TCP/IP 里的传输层；
5. 第五层：会话层，维护网络中的连接状态，即保持会话和同步；
6. 第六层：表示层，把数据转换为合适、可理解的语法和语义；
7. 第七层：应用层，面向具体的应用传输数据。



### HTTP1.1

 HTTP/1.1 长连接特性，默认不会立即关闭连接。



### 浏览器输入网址发生了什么？

1. 客户端从浏览器获取地址和端口
2. 如果获取到的是域名，进行DNS解析，优先到本地的hosts文件中查到，如果找不到去DNS系统中解析(DNS解析时，可能返回的是CDN地址)
3. 拿到IP地址和端口之后，客户端请求服务端建立TCP连接(三次握手)
4. 客户端向服务端发送拼接好的请求报文
5. 服务端向客户端发送拼接好的响应报文
6. 客户端收到响应报文进行解析，渲染页面



### HTTP报文组成

1. 起始行：描述请求或响应的基本信息

   * 请求行
     * 请求方法
     * 请求目标
     * 版本号
   * 相应行
     * 版本号
     * 状态码
     * 状态码原因

2. 头部字段集合：使用Key-Value详细描述请求信息

   * 通用字段：在请求头和响应头中都可以出现
     * date
   * 请求字段
     * host
     * user-agent
   * 响应字段
     * server
   * 实体字段
     * content-length

3. 消息正文：实际传输的数据，不一定是纯文本，可能是图片等

   

### 请求头的注意事项

1. 不区分大小写
2. 字段不允许出现空格
3. 字段名后必须跟上":"，而“:”后的字段值前可以有多个空格
4. 字段的顺序没有意义
5. 字段原则上不能重复



### HTTP传输大文件的方法

1. 数据压缩(缺点：只对text有好效果)
2. 分块传输(Transfer-Encoding: chunked,意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送)
   1. 每个分块包含两个部分
   2. 长度头以CRLF(换行符)结尾的一行明文，用16进制标识
   3. 数据块紧跟在长度头后，最后也用CRLF结尾，但是不包含CRLF
   4. 最后用一个长度为0的块表示结束，即0CRLF
3. 范围请求: HTTP允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。
   1. 检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码 416，意思是“你的范围请求有误，我无法处理，请再检查一下”
   2. 如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。
   3. 服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。
4. 多段数据:一次性获取多个片段数据



“队头阻塞”问题会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。

Cookie 是由浏览器负责存储的，而不是操作系统。所以，它是“浏览器绑定”的，只能在本浏览器内生效。

### Cookie 的属性

1. Expires： 俗称“过期时间”，用的是绝对时间点，可以理解为“截止日期
2. Max-Age：相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间（**浏览器会优先采用 Max-Age 计算失效期**）
3. 作用域
   1. Domain
   2. Path
4. 安全性
   1. HttpOnly：此 Cookie 只能通过浏览器 HTTP 协议传输
   2. SameSite：防范“跨站请求伪造”（XSRF）攻击
   3. Secure：表示这个 Cookie 仅能用 HTTPS 协议加密传输





### HTTP缓存

#### 服务器的缓存控制

1. 浏览器发现缓存无数据，于是发送请求，向服务器获取资源
2. 服务器响应请求，返回资源，同时标记资源的有效期
3. 浏览器缓存资源，等待下次重用
4. 服务器标记资源有效期使用的头字段是“Cache-Control”，里面的值“max-age=30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”

#### Cache-Control状态

* no-store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；
* no-cache：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；
* must-revalidate：又是一个和 no-cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。



#### 

### HTTPS

##### 1.	什么是安全的？

1. 机密性
2. 完整性
3. 身份认证
4. 不可否认

**HTTPS将下层协议换成了SSL/TLS**

![img](D:\Blog\My-Blog\image\http01_1)



##### SSL/TLS

密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法

##### 对称加密

“对称加密”很好理解，就是指加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。

##### 非对称加密

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。

公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

##### 混合加密

- 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;
- 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率





### HTTP2.0

#### 性能优化

1. 头部压缩(HPACK算法)

2. 二进制格式

   1. headers帧
   2. body帧

3. 虚拟的“流”(多路复用)

   1. HTTP/2 在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息

4. 协议栈

   ![img](D:\Blog\My-Blog\image\http01_2)